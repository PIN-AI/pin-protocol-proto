// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: service.proto

package rootlayerv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	IntentPoolService_SubmitIntentBatch_FullMethodName           = "/rootlayer.v1.IntentPoolService/SubmitIntentBatch"
	IntentPoolService_SubmitIntent_FullMethodName                = "/rootlayer.v1.IntentPoolService/SubmitIntent"
	IntentPoolService_GetIntents_FullMethodName                  = "/rootlayer.v1.IntentPoolService/GetIntents"
	IntentPoolService_GetIntent_FullMethodName                   = "/rootlayer.v1.IntentPoolService/GetIntent"
	IntentPoolService_PostAssignment_FullMethodName              = "/rootlayer.v1.IntentPoolService/PostAssignment"
	IntentPoolService_PostAssignmentBatch_FullMethodName         = "/rootlayer.v1.IntentPoolService/PostAssignmentBatch"
	IntentPoolService_PostAssignments_FullMethodName             = "/rootlayer.v1.IntentPoolService/PostAssignments"
	IntentPoolService_SubmitValidationBundle_FullMethodName      = "/rootlayer.v1.IntentPoolService/SubmitValidationBundle"
	IntentPoolService_SubmitValidationBundleBatch_FullMethodName = "/rootlayer.v1.IntentPoolService/SubmitValidationBundleBatch"
)

// IntentPoolServiceClient is the client API for IntentPoolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// IntentPoolService exposes REST endpoints for intent submission,
// querying, and asynchronous callbacks from subnets.
type IntentPoolServiceClient interface {
	// Submit a batch of intents.
	SubmitIntentBatch(ctx context.Context, in *SubmitIntentBatchRequest, opts ...grpc.CallOption) (*SubmitIntentBatchResponse, error)
	// Submit a new intent into the RootLayer mempool.
	//
	// Body is a SubmitIntentRequest. The signature proves ownership of
	// the requester address and integrity of parameters.
	//
	// Example request body:
	//
	//	{
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",
	//	  "requester": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",
	//	  "settleChain": "base_sepolia",
	//	  "intentType": "test",
	//	  "params": {
	//	    "intentRaw": "cGluZ3Jhdw==",
	//	    "metadata": "LXRlc3QgbWV0YS0="
	//	  },
	//	  "tipsToken": "0x0000000000000000000000000000000000000000",
	//	  "tips": "0",
	//	  "deadline": "1822275330",
	//	  "signature": "cfe0c61b6c01fb6b907fd11e550797c761b2cecbc7a3d59e8775fe8640b88c5f1f297f7fdb321c3d1122",
	//	  "budgetToken": "0x0000000000000000000000000000000000000000",
	//	  "budget": "0"
	//	}
	SubmitIntent(ctx context.Context, in *SubmitIntentRequest, opts ...grpc.CallOption) (*SubmitIntentResponse, error)
	// Query intents using multiple filters with pagination.
	GetIntents(ctx context.Context, in *GetIntentsRequest, opts ...grpc.CallOption) (*GetIntentsResponse, error)
	// Fetch a single intent by its ID.
	GetIntent(ctx context.Context, in *GetIntentRequest, opts ...grpc.CallOption) (*Intent, error)
	// Post a single assignment from a subnet matcher.
	//
	// Example request body:
	//
	//	{
	//	  "assignmentId": "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", // bytes32 hex
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d", // bytes32 hex
	//	  "agentId": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",                         // address (EIP-55 tolerated)
	//	  "bidId": "0x0000000000000000000000000000000000000000000000000000000000000000",   // bytes32 hex
	//	  "status": 1, // 1=ACTIVE, 2=FAILED
	//	  "matcherId": "0xF39fd6e51aad88F6F4ce6aB8827279cffFb92266",                          // address
	//	  "signature": "0x..65-bytes-signature.."                                                // EIP-191 signature
	//	}
	PostAssignment(ctx context.Context, in *Assignment, opts ...grpc.CallOption) (*Ack, error)
	// Post a batch of assignments from a subnet matcher.
	PostAssignmentBatch(ctx context.Context, in *AssignmentBatch, opts ...grpc.CallOption) (*Ack, error)
	// Deprecated alias for backward compatibility.
	PostAssignments(ctx context.Context, in *AssignmentBatch, opts ...grpc.CallOption) (*Ack, error)
	// Submit an aggregated ValidationBundle from subnet validators.
	//
	// Example request body:
	//
	//	{
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",  // bytes32 hex
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",  // bytes32 hex
	//	  "assignmentId": "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", // bytes32 hex
	//	  "agentId": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",                           // address
	//	  "rootHeight": "1",
	//	  "rootHash": "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", // bytes32 hex
	//	  "executedAt": "1",
	//	  "resultHash": "0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc", // bytes32 hex
	//	  "proofHash": "0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd",  // bytes32 hex
	//	  "signatures": [
	//	    { "validator": "0xF39fd6e51aad88F6F4ce6aB8827279cffFb92266", "signature": "0x..65-bytes.." }
	//	  ],
	//	  "signerBitmap": "0x01",
	//	  "totalWeight": "1",
	//	  "aggregatorId": "0xF39fd6e51aad88F6F4ce6aB8827279cffFb92266",
	//	  "completedAt": "1822275330"
	//	}
	SubmitValidationBundle(ctx context.Context, in *ValidationBundle, opts ...grpc.CallOption) (*ValidationAck, error)
	// Submit a batch of validation bundles.
	SubmitValidationBundleBatch(ctx context.Context, in *ValidationBundleBatchRequest, opts ...grpc.CallOption) (*ValidationBundleBatchResponse, error)
}

type intentPoolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIntentPoolServiceClient(cc grpc.ClientConnInterface) IntentPoolServiceClient {
	return &intentPoolServiceClient{cc}
}

func (c *intentPoolServiceClient) SubmitIntentBatch(ctx context.Context, in *SubmitIntentBatchRequest, opts ...grpc.CallOption) (*SubmitIntentBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitIntentBatchResponse)
	err := c.cc.Invoke(ctx, IntentPoolService_SubmitIntentBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) SubmitIntent(ctx context.Context, in *SubmitIntentRequest, opts ...grpc.CallOption) (*SubmitIntentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitIntentResponse)
	err := c.cc.Invoke(ctx, IntentPoolService_SubmitIntent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) GetIntents(ctx context.Context, in *GetIntentsRequest, opts ...grpc.CallOption) (*GetIntentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIntentsResponse)
	err := c.cc.Invoke(ctx, IntentPoolService_GetIntents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) GetIntent(ctx context.Context, in *GetIntentRequest, opts ...grpc.CallOption) (*Intent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Intent)
	err := c.cc.Invoke(ctx, IntentPoolService_GetIntent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) PostAssignment(ctx context.Context, in *Assignment, opts ...grpc.CallOption) (*Ack, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ack)
	err := c.cc.Invoke(ctx, IntentPoolService_PostAssignment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) PostAssignmentBatch(ctx context.Context, in *AssignmentBatch, opts ...grpc.CallOption) (*Ack, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ack)
	err := c.cc.Invoke(ctx, IntentPoolService_PostAssignmentBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) PostAssignments(ctx context.Context, in *AssignmentBatch, opts ...grpc.CallOption) (*Ack, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Ack)
	err := c.cc.Invoke(ctx, IntentPoolService_PostAssignments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) SubmitValidationBundle(ctx context.Context, in *ValidationBundle, opts ...grpc.CallOption) (*ValidationAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidationAck)
	err := c.cc.Invoke(ctx, IntentPoolService_SubmitValidationBundle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intentPoolServiceClient) SubmitValidationBundleBatch(ctx context.Context, in *ValidationBundleBatchRequest, opts ...grpc.CallOption) (*ValidationBundleBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidationBundleBatchResponse)
	err := c.cc.Invoke(ctx, IntentPoolService_SubmitValidationBundleBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntentPoolServiceServer is the server API for IntentPoolService service.
// All implementations must embed UnimplementedIntentPoolServiceServer
// for forward compatibility.
//
// IntentPoolService exposes REST endpoints for intent submission,
// querying, and asynchronous callbacks from subnets.
type IntentPoolServiceServer interface {
	// Submit a batch of intents.
	SubmitIntentBatch(context.Context, *SubmitIntentBatchRequest) (*SubmitIntentBatchResponse, error)
	// Submit a new intent into the RootLayer mempool.
	//
	// Body is a SubmitIntentRequest. The signature proves ownership of
	// the requester address and integrity of parameters.
	//
	// Example request body:
	//
	//	{
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",
	//	  "requester": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",
	//	  "settleChain": "base_sepolia",
	//	  "intentType": "test",
	//	  "params": {
	//	    "intentRaw": "cGluZ3Jhdw==",
	//	    "metadata": "LXRlc3QgbWV0YS0="
	//	  },
	//	  "tipsToken": "0x0000000000000000000000000000000000000000",
	//	  "tips": "0",
	//	  "deadline": "1822275330",
	//	  "signature": "cfe0c61b6c01fb6b907fd11e550797c761b2cecbc7a3d59e8775fe8640b88c5f1f297f7fdb321c3d1122",
	//	  "budgetToken": "0x0000000000000000000000000000000000000000",
	//	  "budget": "0"
	//	}
	SubmitIntent(context.Context, *SubmitIntentRequest) (*SubmitIntentResponse, error)
	// Query intents using multiple filters with pagination.
	GetIntents(context.Context, *GetIntentsRequest) (*GetIntentsResponse, error)
	// Fetch a single intent by its ID.
	GetIntent(context.Context, *GetIntentRequest) (*Intent, error)
	// Post a single assignment from a subnet matcher.
	//
	// Example request body:
	//
	//	{
	//	  "assignmentId": "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", // bytes32 hex
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d", // bytes32 hex
	//	  "agentId": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",                         // address (EIP-55 tolerated)
	//	  "bidId": "0x0000000000000000000000000000000000000000000000000000000000000000",   // bytes32 hex
	//	  "status": 1, // 1=ACTIVE, 2=FAILED
	//	  "matcherId": "0xF39fd6e51aad88F6F4ce6aB8827279cffFb92266",                          // address
	//	  "signature": "0x..65-bytes-signature.."                                                // EIP-191 signature
	//	}
	PostAssignment(context.Context, *Assignment) (*Ack, error)
	// Post a batch of assignments from a subnet matcher.
	PostAssignmentBatch(context.Context, *AssignmentBatch) (*Ack, error)
	// Deprecated alias for backward compatibility.
	PostAssignments(context.Context, *AssignmentBatch) (*Ack, error)
	// Submit an aggregated ValidationBundle from subnet validators.
	//
	// Example request body:
	//
	//	{
	//	  "subnetId": "0x0000000000000000000000000000000000000000000000000000000000000001",  // bytes32 hex
	//	  "intentId": "0xb7c98798a6ec454427a60cff94b54276fe82396f714c02499a40c8f3f6325f8d",  // bytes32 hex
	//	  "assignmentId": "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", // bytes32 hex
	//	  "agentId": "0x9290085Cd66bD1A3C7D277EF7DBcbD2e98457b6f",                           // address
	//	  "rootHeight": "1",
	//	  "rootHash": "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", // bytes32 hex
	//	  "executedAt": "1",
	//	  "resultHash": "0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc", // bytes32 hex
	//	  "proofHash": "0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd",  // bytes32 hex
	//	  "signatures": [
	//	    { "validator": "0xF39fd6e51aad88F6F4ce6aB8827279cffFb92266", "signature": "0x..65-bytes.." }
	//	  ],
	//	  "signerBitmap": "0x01",
	//	  "totalWeight": "1",
	//	  "aggregatorId": "0xF39fd6e51aad88F6F4ce6aB8827279cffFb92266",
	//	  "completedAt": "1822275330"
	//	}
	SubmitValidationBundle(context.Context, *ValidationBundle) (*ValidationAck, error)
	// Submit a batch of validation bundles.
	SubmitValidationBundleBatch(context.Context, *ValidationBundleBatchRequest) (*ValidationBundleBatchResponse, error)
	mustEmbedUnimplementedIntentPoolServiceServer()
}

// UnimplementedIntentPoolServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIntentPoolServiceServer struct{}

func (UnimplementedIntentPoolServiceServer) SubmitIntentBatch(context.Context, *SubmitIntentBatchRequest) (*SubmitIntentBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitIntentBatch not implemented")
}
func (UnimplementedIntentPoolServiceServer) SubmitIntent(context.Context, *SubmitIntentRequest) (*SubmitIntentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitIntent not implemented")
}
func (UnimplementedIntentPoolServiceServer) GetIntents(context.Context, *GetIntentsRequest) (*GetIntentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntents not implemented")
}
func (UnimplementedIntentPoolServiceServer) GetIntent(context.Context, *GetIntentRequest) (*Intent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntent not implemented")
}
func (UnimplementedIntentPoolServiceServer) PostAssignment(context.Context, *Assignment) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAssignment not implemented")
}
func (UnimplementedIntentPoolServiceServer) PostAssignmentBatch(context.Context, *AssignmentBatch) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAssignmentBatch not implemented")
}
func (UnimplementedIntentPoolServiceServer) PostAssignments(context.Context, *AssignmentBatch) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAssignments not implemented")
}
func (UnimplementedIntentPoolServiceServer) SubmitValidationBundle(context.Context, *ValidationBundle) (*ValidationAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitValidationBundle not implemented")
}
func (UnimplementedIntentPoolServiceServer) SubmitValidationBundleBatch(context.Context, *ValidationBundleBatchRequest) (*ValidationBundleBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitValidationBundleBatch not implemented")
}
func (UnimplementedIntentPoolServiceServer) mustEmbedUnimplementedIntentPoolServiceServer() {}
func (UnimplementedIntentPoolServiceServer) testEmbeddedByValue()                           {}

// UnsafeIntentPoolServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntentPoolServiceServer will
// result in compilation errors.
type UnsafeIntentPoolServiceServer interface {
	mustEmbedUnimplementedIntentPoolServiceServer()
}

func RegisterIntentPoolServiceServer(s grpc.ServiceRegistrar, srv IntentPoolServiceServer) {
	// If the following call pancis, it indicates UnimplementedIntentPoolServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IntentPoolService_ServiceDesc, srv)
}

func _IntentPoolService_SubmitIntentBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitIntentBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).SubmitIntentBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_SubmitIntentBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).SubmitIntentBatch(ctx, req.(*SubmitIntentBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_SubmitIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitIntentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).SubmitIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_SubmitIntent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).SubmitIntent(ctx, req.(*SubmitIntentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_GetIntents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).GetIntents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_GetIntents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).GetIntents(ctx, req.(*GetIntentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_GetIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).GetIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_GetIntent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).GetIntent(ctx, req.(*GetIntentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_PostAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Assignment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).PostAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_PostAssignment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).PostAssignment(ctx, req.(*Assignment))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_PostAssignmentBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignmentBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).PostAssignmentBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_PostAssignmentBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).PostAssignmentBatch(ctx, req.(*AssignmentBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_PostAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignmentBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).PostAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_PostAssignments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).PostAssignments(ctx, req.(*AssignmentBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_SubmitValidationBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidationBundle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).SubmitValidationBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_SubmitValidationBundle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).SubmitValidationBundle(ctx, req.(*ValidationBundle))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntentPoolService_SubmitValidationBundleBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidationBundleBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentPoolServiceServer).SubmitValidationBundleBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IntentPoolService_SubmitValidationBundleBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentPoolServiceServer).SubmitValidationBundleBatch(ctx, req.(*ValidationBundleBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IntentPoolService_ServiceDesc is the grpc.ServiceDesc for IntentPoolService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IntentPoolService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.IntentPoolService",
	HandlerType: (*IntentPoolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitIntentBatch",
			Handler:    _IntentPoolService_SubmitIntentBatch_Handler,
		},
		{
			MethodName: "SubmitIntent",
			Handler:    _IntentPoolService_SubmitIntent_Handler,
		},
		{
			MethodName: "GetIntents",
			Handler:    _IntentPoolService_GetIntents_Handler,
		},
		{
			MethodName: "GetIntent",
			Handler:    _IntentPoolService_GetIntent_Handler,
		},
		{
			MethodName: "PostAssignment",
			Handler:    _IntentPoolService_PostAssignment_Handler,
		},
		{
			MethodName: "PostAssignmentBatch",
			Handler:    _IntentPoolService_PostAssignmentBatch_Handler,
		},
		{
			MethodName: "PostAssignments",
			Handler:    _IntentPoolService_PostAssignments_Handler,
		},
		{
			MethodName: "SubmitValidationBundle",
			Handler:    _IntentPoolService_SubmitValidationBundle_Handler,
		},
		{
			MethodName: "SubmitValidationBundleBatch",
			Handler:    _IntentPoolService_SubmitValidationBundleBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	SubscriptionService_SubscribeIntents_FullMethodName       = "/rootlayer.v1.SubscriptionService/SubscribeIntents"
	SubscriptionService_SubscribeStatusUpdates_FullMethodName = "/rootlayer.v1.SubscriptionService/SubscribeStatusUpdates"
)

// SubscriptionServiceClient is the client API for SubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// gRPC streaming subscription service (not exposed via OpenAPI).
type SubscriptionServiceClient interface {
	// Subscribe to the real-time intent stream filtered by subnet and metadata.
	SubscribeIntents(ctx context.Context, in *SubscribeIntentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IntentStreamEvent], error)
	// Subscribe to status change notifications for one or more intents.
	SubscribeStatusUpdates(ctx context.Context, in *SubscribeStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusUpdateEvent], error)
}

type subscriptionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscriptionServiceClient(cc grpc.ClientConnInterface) SubscriptionServiceClient {
	return &subscriptionServiceClient{cc}
}

func (c *subscriptionServiceClient) SubscribeIntents(ctx context.Context, in *SubscribeIntentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IntentStreamEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SubscriptionService_ServiceDesc.Streams[0], SubscriptionService_SubscribeIntents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeIntentsRequest, IntentStreamEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeIntentsClient = grpc.ServerStreamingClient[IntentStreamEvent]

func (c *subscriptionServiceClient) SubscribeStatusUpdates(ctx context.Context, in *SubscribeStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusUpdateEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SubscriptionService_ServiceDesc.Streams[1], SubscriptionService_SubscribeStatusUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeStatusRequest, StatusUpdateEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeStatusUpdatesClient = grpc.ServerStreamingClient[StatusUpdateEvent]

// SubscriptionServiceServer is the server API for SubscriptionService service.
// All implementations must embed UnimplementedSubscriptionServiceServer
// for forward compatibility.
//
// gRPC streaming subscription service (not exposed via OpenAPI).
type SubscriptionServiceServer interface {
	// Subscribe to the real-time intent stream filtered by subnet and metadata.
	SubscribeIntents(*SubscribeIntentsRequest, grpc.ServerStreamingServer[IntentStreamEvent]) error
	// Subscribe to status change notifications for one or more intents.
	SubscribeStatusUpdates(*SubscribeStatusRequest, grpc.ServerStreamingServer[StatusUpdateEvent]) error
	mustEmbedUnimplementedSubscriptionServiceServer()
}

// UnimplementedSubscriptionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSubscriptionServiceServer struct{}

func (UnimplementedSubscriptionServiceServer) SubscribeIntents(*SubscribeIntentsRequest, grpc.ServerStreamingServer[IntentStreamEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeIntents not implemented")
}
func (UnimplementedSubscriptionServiceServer) SubscribeStatusUpdates(*SubscribeStatusRequest, grpc.ServerStreamingServer[StatusUpdateEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeStatusUpdates not implemented")
}
func (UnimplementedSubscriptionServiceServer) mustEmbedUnimplementedSubscriptionServiceServer() {}
func (UnimplementedSubscriptionServiceServer) testEmbeddedByValue()                             {}

// UnsafeSubscriptionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubscriptionServiceServer will
// result in compilation errors.
type UnsafeSubscriptionServiceServer interface {
	mustEmbedUnimplementedSubscriptionServiceServer()
}

func RegisterSubscriptionServiceServer(s grpc.ServiceRegistrar, srv SubscriptionServiceServer) {
	// If the following call pancis, it indicates UnimplementedSubscriptionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SubscriptionService_ServiceDesc, srv)
}

func _SubscriptionService_SubscribeIntents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeIntentsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriptionServiceServer).SubscribeIntents(m, &grpc.GenericServerStream[SubscribeIntentsRequest, IntentStreamEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeIntentsServer = grpc.ServerStreamingServer[IntentStreamEvent]

func _SubscriptionService_SubscribeStatusUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriptionServiceServer).SubscribeStatusUpdates(m, &grpc.GenericServerStream[SubscribeStatusRequest, StatusUpdateEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SubscriptionService_SubscribeStatusUpdatesServer = grpc.ServerStreamingServer[StatusUpdateEvent]

// SubscriptionService_ServiceDesc is the grpc.ServiceDesc for SubscriptionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SubscriptionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.SubscriptionService",
	HandlerType: (*SubscriptionServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeIntents",
			Handler:       _SubscriptionService_SubscribeIntents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeStatusUpdates",
			Handler:       _SubscriptionService_SubscribeStatusUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	HealthService_Check_FullMethodName = "/rootlayer.v1.HealthService/Check"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Liveness and version information.
type HealthServiceClient interface {
	Check(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Check(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_Check_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
//
// Liveness and version information.
type HealthServiceServer interface {
	Check(context.Context, *emptypb.Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) Check(context.Context, *emptypb.Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call pancis, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Check(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _HealthService_Check_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

const (
	RelayerService_AgentConnect_FullMethodName       = "/rootlayer.v1.RelayerService/AgentConnect"
	RelayerService_SubmitDirectResult_FullMethodName = "/rootlayer.v1.RelayerService/SubmitDirectResult"
	RelayerService_Heartbeat_FullMethodName          = "/rootlayer.v1.RelayerService/Heartbeat"
)

// RelayerServiceClient is the client API for RelayerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RelayerService handles Agent connections and Direct Intent dispatching
type RelayerServiceClient interface {
	// AgentConnect establishes a long-lived stream for Direct Intent delivery
	// Agent receives DirectIntentPush messages through this stream
	AgentConnect(ctx context.Context, in *AgentConnectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DirectIntentPush], error)
	// SubmitDirectResult allows Agent to submit execution results
	SubmitDirectResult(ctx context.Context, in *DirectResultRequest, opts ...grpc.CallOption) (*DirectResultResponse, error)
	// Heartbeat keeps the Agent connection alive
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type relayerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRelayerServiceClient(cc grpc.ClientConnInterface) RelayerServiceClient {
	return &relayerServiceClient{cc}
}

func (c *relayerServiceClient) AgentConnect(ctx context.Context, in *AgentConnectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DirectIntentPush], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RelayerService_ServiceDesc.Streams[0], RelayerService_AgentConnect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AgentConnectRequest, DirectIntentPush]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RelayerService_AgentConnectClient = grpc.ServerStreamingClient[DirectIntentPush]

func (c *relayerServiceClient) SubmitDirectResult(ctx context.Context, in *DirectResultRequest, opts ...grpc.CallOption) (*DirectResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DirectResultResponse)
	err := c.cc.Invoke(ctx, RelayerService_SubmitDirectResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayerService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayerServiceServer is the server API for RelayerService service.
// All implementations must embed UnimplementedRelayerServiceServer
// for forward compatibility.
//
// RelayerService handles Agent connections and Direct Intent dispatching
type RelayerServiceServer interface {
	// AgentConnect establishes a long-lived stream for Direct Intent delivery
	// Agent receives DirectIntentPush messages through this stream
	AgentConnect(*AgentConnectRequest, grpc.ServerStreamingServer[DirectIntentPush]) error
	// SubmitDirectResult allows Agent to submit execution results
	SubmitDirectResult(context.Context, *DirectResultRequest) (*DirectResultResponse, error)
	// Heartbeat keeps the Agent connection alive
	Heartbeat(context.Context, *HeartbeatRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRelayerServiceServer()
}

// UnimplementedRelayerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRelayerServiceServer struct{}

func (UnimplementedRelayerServiceServer) AgentConnect(*AgentConnectRequest, grpc.ServerStreamingServer[DirectIntentPush]) error {
	return status.Errorf(codes.Unimplemented, "method AgentConnect not implemented")
}
func (UnimplementedRelayerServiceServer) SubmitDirectResult(context.Context, *DirectResultRequest) (*DirectResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitDirectResult not implemented")
}
func (UnimplementedRelayerServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedRelayerServiceServer) mustEmbedUnimplementedRelayerServiceServer() {}
func (UnimplementedRelayerServiceServer) testEmbeddedByValue()                        {}

// UnsafeRelayerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RelayerServiceServer will
// result in compilation errors.
type UnsafeRelayerServiceServer interface {
	mustEmbedUnimplementedRelayerServiceServer()
}

func RegisterRelayerServiceServer(s grpc.ServiceRegistrar, srv RelayerServiceServer) {
	// If the following call pancis, it indicates UnimplementedRelayerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RelayerService_ServiceDesc, srv)
}

func _RelayerService_AgentConnect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AgentConnectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RelayerServiceServer).AgentConnect(m, &grpc.GenericServerStream[AgentConnectRequest, DirectIntentPush]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RelayerService_AgentConnectServer = grpc.ServerStreamingServer[DirectIntentPush]

func _RelayerService_SubmitDirectResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DirectResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServiceServer).SubmitDirectResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerService_SubmitDirectResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServiceServer).SubmitDirectResult(ctx, req.(*DirectResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayerService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayerService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RelayerService_ServiceDesc is the grpc.ServiceDesc for RelayerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RelayerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.RelayerService",
	HandlerType: (*RelayerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitDirectResult",
			Handler:    _RelayerService_SubmitDirectResult_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _RelayerService_Heartbeat_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AgentConnect",
			Handler:       _RelayerService_AgentConnect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

const (
	DirectIntentService_SubmitDirectIntent_FullMethodName = "/rootlayer.v1.DirectIntentService/SubmitDirectIntent"
	DirectIntentService_GetDirectResult_FullMethodName    = "/rootlayer.v1.DirectIntentService/GetDirectResult"
)

// DirectIntentServiceClient is the client API for DirectIntentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DirectIntentService handles user Direct Intent submissions and queries
type DirectIntentServiceClient interface {
	// SubmitDirectIntent submits a Direct Intent and waits for Agent response
	// Supports hybrid sync/async mode: returns result within timeout, or returns intent_id for async query
	SubmitDirectIntent(ctx context.Context, in *SubmitDirectIntentRequest, opts ...grpc.CallOption) (*SubmitDirectIntentResponse, error)
	// GetDirectResult queries the execution result of a Direct Intent
	GetDirectResult(ctx context.Context, in *GetDirectResultRequest, opts ...grpc.CallOption) (*DirectResultDetail, error)
}

type directIntentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDirectIntentServiceClient(cc grpc.ClientConnInterface) DirectIntentServiceClient {
	return &directIntentServiceClient{cc}
}

func (c *directIntentServiceClient) SubmitDirectIntent(ctx context.Context, in *SubmitDirectIntentRequest, opts ...grpc.CallOption) (*SubmitDirectIntentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitDirectIntentResponse)
	err := c.cc.Invoke(ctx, DirectIntentService_SubmitDirectIntent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directIntentServiceClient) GetDirectResult(ctx context.Context, in *GetDirectResultRequest, opts ...grpc.CallOption) (*DirectResultDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DirectResultDetail)
	err := c.cc.Invoke(ctx, DirectIntentService_GetDirectResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DirectIntentServiceServer is the server API for DirectIntentService service.
// All implementations must embed UnimplementedDirectIntentServiceServer
// for forward compatibility.
//
// DirectIntentService handles user Direct Intent submissions and queries
type DirectIntentServiceServer interface {
	// SubmitDirectIntent submits a Direct Intent and waits for Agent response
	// Supports hybrid sync/async mode: returns result within timeout, or returns intent_id for async query
	SubmitDirectIntent(context.Context, *SubmitDirectIntentRequest) (*SubmitDirectIntentResponse, error)
	// GetDirectResult queries the execution result of a Direct Intent
	GetDirectResult(context.Context, *GetDirectResultRequest) (*DirectResultDetail, error)
	mustEmbedUnimplementedDirectIntentServiceServer()
}

// UnimplementedDirectIntentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDirectIntentServiceServer struct{}

func (UnimplementedDirectIntentServiceServer) SubmitDirectIntent(context.Context, *SubmitDirectIntentRequest) (*SubmitDirectIntentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitDirectIntent not implemented")
}
func (UnimplementedDirectIntentServiceServer) GetDirectResult(context.Context, *GetDirectResultRequest) (*DirectResultDetail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDirectResult not implemented")
}
func (UnimplementedDirectIntentServiceServer) mustEmbedUnimplementedDirectIntentServiceServer() {}
func (UnimplementedDirectIntentServiceServer) testEmbeddedByValue()                             {}

// UnsafeDirectIntentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DirectIntentServiceServer will
// result in compilation errors.
type UnsafeDirectIntentServiceServer interface {
	mustEmbedUnimplementedDirectIntentServiceServer()
}

func RegisterDirectIntentServiceServer(s grpc.ServiceRegistrar, srv DirectIntentServiceServer) {
	// If the following call pancis, it indicates UnimplementedDirectIntentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DirectIntentService_ServiceDesc, srv)
}

func _DirectIntentService_SubmitDirectIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitDirectIntentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectIntentServiceServer).SubmitDirectIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectIntentService_SubmitDirectIntent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectIntentServiceServer).SubmitDirectIntent(ctx, req.(*SubmitDirectIntentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectIntentService_GetDirectResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDirectResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectIntentServiceServer).GetDirectResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectIntentService_GetDirectResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectIntentServiceServer).GetDirectResult(ctx, req.(*GetDirectResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DirectIntentService_ServiceDesc is the grpc.ServiceDesc for DirectIntentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DirectIntentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rootlayer.v1.DirectIntentService",
	HandlerType: (*DirectIntentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitDirectIntent",
			Handler:    _DirectIntentService_SubmitDirectIntent_Handler,
		},
		{
			MethodName: "GetDirectResult",
			Handler:    _DirectIntentService_GetDirectResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
